# Database Patterns and SQLModel Conventions

## SQLModel Usage
- Define all models in `backend/db_models.py`
- Use SQLModel for both Pydantic validation and SQLAlchemy ORM
- Use proper table relationships and foreign keys
- Include audit trails for data changes

## Model Structure
```python
class Mixtape(SQLModel, table=True):
    __tablename__ = "Mixtape"
    id: Optional[int] = Field(default=None, primary_key=True)
    public_id: str = Field(unique=True, index=True)
    name: str = Field(max_length=255)
    # Relationships
    tracks: List["MixtapeTrack"] = Relationship(back_populates="mixtape")
```

## Naming Conventions
- Use PascalCase for table names
- Use snake_case for column names
- Use descriptive names for indexes and constraints
- Follow consistent naming patterns

## Relationships
- Define bidirectional relationships with `back_populates`
- Use `cascade_delete=True` for dependent relationships
- Include proper foreign key constraints
- Use appropriate relationship types (One-to-Many, Many-to-One)

## Indexes and Performance
- Add indexes for frequently queried columns
- Use composite indexes for multi-column queries
- Consider query patterns when designing indexes
- Monitor query performance

## Audit Trail
- Include audit tables for tracking changes
- Store version information for data changes
- Track creation and modification timestamps
- Maintain data integrity across versions

## Schema Generation
- Auto-generate schema from SQLModel using `scripts/generate_schema.py`
- Never edit `schema.gen.sql` directly
- Run generation after model changes
- Include generated schema in version control
description:
globs:
alwaysApply: false
---
