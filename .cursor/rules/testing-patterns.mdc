# Testing Patterns and Conventions

## Frontend Testing (Jest + React Testing Library)

### Test File Organization
```
app/components/__tests__/
├── ComponentName.test.tsx
├── test-utils.tsx          # Shared test utilities
└── __mocks__/             # Mock files
```

### Testing Patterns
- Use `@testing-library/react` for component rendering
- Use `@testing-library/user-event` for user interactions
- Test user behavior, not implementation details
- Use semantic queries (getByRole, getByLabelText) over test IDs

### Example Test Structure
```typescript
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import ComponentName from '../ComponentName';

describe('ComponentName', () => {
  it('should render correctly', () => {
    render(<ComponentName title="Test" />);
    expect(screen.getByText('Test')).toBeInTheDocument();
  });

  it('should handle user interactions', async () => {
    const user = userEvent.setup();
    render(<ComponentName onSave={jest.fn()} />);
    
    await user.click(screen.getByRole('button', { name: /save/i }));
    // Assert expected behavior
  });
});
```

## Backend Testing (pytest)

### Test File Organization
```
backend/tests/
├── test_mixtape_api.py
├── test_spotify_api.py
└── conftest.py            # Shared fixtures
```

### Testing Patterns
- Use pytest for all backend tests
- Use dependency overrides for external services
- Use temporary PostgreSQL database for integration tests
- Test both success and error scenarios

### Example Test Structure
```python
import pytest
from fastapi.testclient import TestClient
from backend.app_factory import create_app

@pytest.fixture
def client():
    app = create_app()
    return TestClient(app)

def test_create_mixtape(client, mock_spotify_client):
    response = client.post("/api/mixtape", json={
        "name": "Test Mixtape",
        "tracks": [{"track_position": 1, "spotify_uri": "spotify:track:123"}]
    })
    assert response.status_code == 201
```

## Mock Patterns

### Frontend Mocks
- Mock external APIs and services
- Use `jest.mock()` for module mocking
- Create mock data that matches real API responses
- Mock authentication state for protected components

### Backend Mocks
- Use dependency overrides for external services
- Mock Spotify API responses
- Mock database sessions when needed
- Use pytest fixtures for reusable mocks

## Test Data
- Use realistic test data that matches production
- Create factory functions for test data generation
- Use consistent test data across related tests
- Clean up test data after tests

## Coverage Goals
- Aim for >80% code coverage
- Focus on critical user paths
- Test error scenarios and edge cases
- Test accessibility features
description:
globs:
alwaysApply: false
---
